# LAB 5: 死锁检测

### 功能总结

在 PCB 中新增对应的三个向量, 按照算法描述完成代码编写, 成功实现死锁检测.  

### 简答题

1. 在我们的多线程实现中, 当主线程 (即 0 号线程) 退出时, 视为整个进程退出, 此时需要结束该进程管理的所有线程并回收其资源.
   - 需要回收的资源有哪些?
        > 地址空间, 文件描述符表, 互斥锁, 信号量, 条件变量, 子进程, 子线程.  

   - 其他线程的 `TaskControlBlock` 可能在哪些位置被引用, 分别是否需要回收, 为什么?
        > 可能在 PCB 的线程列表, 互斥锁/信号量/条件变量的等待队列等位置被引用, 但是这些结构都属于 PCB, 在释放进程的时候会逐个释放, 最终 `Arc` 的强引用计数降为 0, TCB 被自动回收.  

2. 对比以下两种 `Mutex.unlock` 的实现, 二者有什么区别? 这些区别可能会导致什么问题? 
   > 第一种实现必将锁的状态置为 `false`, 第二种实现则只有在没有线程在等待时才会置为 `false`. 在第一种实现下, 被唤醒的线程进入了临界区, 但是此时锁的状态仍为 `false`, 如果在之后的调度中又有其他线程尝试获取锁, 就会导致竞态条件.  


### 荣誉准则
1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
    > 无

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：
    > 参考了往年的[实验讲解](https://github.com/xushanpu123/xsp-daily-work/blob/master/chapter%208%EF%BC%9A%E5%B9%B6%E5%8F%91%E4%B8%8E%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE.md), 对照我的代码和参考实现, 查找问题, 代码中已标注参考后修改的内容 (共 3 处).  

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。